[{"content":"第二章：元数据获取\r这一部分，我们就来使用上一章介绍的芝士获取结构体的元信息。\n参考链接：\n编译期反射成员名称：https://lumia431.github.io/2025/05/09/%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E7%BC%96%E8%AF%91%E6%9C%9F%E5%8F%8D%E5%B0%84%E5%88%9D%E6%8E%A2%EF%BC%81%EF%BC%81/\n编译期获取结构体成员数量：https://zhuanlan.zhihu.com/p/674157958\n侵入式编译期反射：https://netcan.github.io/2020/08/01/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%AE%9E%E7%8E%B0C-%E7%BC%96%E8%AF%91%E6%9C%9F%E9%9D%99%E6%80%81%E5%8F%8D%E5%B0%84/\n结构体成员名称获取\r​\t上一章我们提到，可以通过编译器内置的宏（MSVC：__FUNCSIG__、clang、gcc：__PRETTY_FUNCTION__）来获取成员变量名称，具体表现为：\n1 // void __cdecl get_func_name_template\u0026lt;\u0026amp;p.m_name\u0026gt;(void) 定义一个示例用的结构体：struct Person { int m_age; std::string m_name; };\n那么，通过一定的字符串截取，我们就可以拿到一个结构体成员的名称：\n1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;auto val\u0026gt; inline constexpr std::string_view get_member_type_name() { #if defined(_MSC_VER) std::string_view funcName = __FUNCSIG__; size_t begin = funcName.rfind(\u0026#34;.\u0026#34;) + 1; size_t end = funcName.rfind(\u0026#34;\u0026gt;(\u0026#34;); return funcName.substr(begin, end - begin); #endif } static Person p; get_func_name_template\u0026lt;\u0026amp;p.m_name\u0026gt;(); // out: m_name 但是，对于一个用于存储网络请求的结构体来说，结构体成员的数量可能非常多，如果对于每一个都这样手动的去获取，和REFLECTION(Person, m_name, m_age)就没区别了，这时候上一章讲到的结构化绑定就派上用场了，能够想到：\n1 2 3 4 5 int main () { static Person p; auto\u0026amp; [age, name] = p; get_member_type_name\u0026lt;\u0026amp;age\u0026gt;(); } 但是编译后会发现报错：error C2672: “get_member_type_name”: 未找到匹配的重载函数，这是因为age 是局部结构化绑定引用，\u0026amp;age 不是地址常量表达式。所以对于\u0026amp;p是可以的，但是\u0026amp;age不行。核心在于，我们需要告诉编译器，age是一个编译期常量，对于这个问题，解决方案如下：\n1 2 3 4 5 6 inline constexpr auto get_tuple() { auto\u0026amp; [a, b] = p;\treturn std::tie(a, b);\t} std::cout \u0026lt;\u0026lt; get_member_type_name\u0026lt;\u0026amp;std::get\u0026lt;1\u0026gt;(get_tuple())\u0026gt;() \u0026lt;\u0026lt; std::endl; // out: m_name get_tuple()函数的返回值被修饰为constexpr表示这个函数可以在编译期被调用，而对于tuple，编译器在编译期会将其折叠为：p.m_name的引用，这时候再取地址就没有问题了。\n不过现在我们的Person的全局成员p也需要使用者自己定义，同时get_tuple函数只能支持两个成员的函数，作为一个可用性强的库来说，这些都是不应该存在的。\n定义全局唯一对象\r为了解决第一个问题，我们就需要针对不同的用户类型做统一处理，可以想到的是：\n1 2 3 4 template \u0026lt;typename T\u0026gt; struct Wrapper { inline static std::remove_cvref_t\u0026lt;T\u0026gt; value; }; 针对任意对象，定义一个全局存在的唯一实例，并用Wrapper匿名起来，这里就是一个静态反射的额外开销，只要做一次反射，该类型就会有且仅有一个唯一实例被创建在内存当中。\n此时我们就可以实现对任意对象的元组获取：\n1 2 3 4 5 6 7 template \u0026lt;typename T\u0026gt; inline constexpr auto get_tuple() { auto\u0026amp; [a, b] = Wrapper\u0026lt;T\u0026gt;::value;\treturn std::tie(a, b);\t} std::cout \u0026lt;\u0026lt; get_member_type_name\u0026lt;\u0026amp;std::get\u0026lt;1\u0026gt;(get_tuple\u0026lt;Person\u0026gt;())\u0026gt;() \u0026lt;\u0026lt; std::endl; // out: m_name 支持不同结构体成员数量的结构化绑定\r第二个问题没有办法绕过，目前只能通过手动打表的方式实现对不同数量成员结构体的结构化匹配，不过这里的表可以通过脚本实现，也不麻烦：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 template \u0026lt;AggregateType T, size_t N\u0026gt; struct get_member_references_tuple { // get tuple by type inline static constexpr auto get_tuple() { if constexpr (N \u0026lt;= 0) { static_assert(N \u0026lt;= 0, \u0026#34;Too few structural member parameters (size \u0026lt;= 0)\u0026#34;); } else { static_assert(N \u0026gt; 5, \u0026#34;Too many structural member parameters (size \u0026gt;= 3)\u0026#34;); } } } #define GET_MEMBER_TUPLE_HELPER(n, ...) \\ // 对结构体的偏特化 template \u0026lt;AggregateType T\u0026gt; \\ struct get_member_references_tuple\u0026lt;T, n\u0026gt; { \\ inline static constexpr auto get_tuple() { \\ auto\u0026amp; [__VA_ARGS__] = Wrapper\u0026lt;T\u0026gt;::value;\t\\ return std::tie(__VA_ARGS__);\t\\ } \\ } GET_MEMBER_TUPLE_HELPER(1, a) GET_MEMBER_TUPLE_HELPER(2, a, b) GET_MEMBER_TUPLE_HELPER(3, a, b, c) ... 这里使用struct包装是因为普通函数不允许偏特化，而我们需要根据不同的成员变量数量进行不同实现的匹配，但我们如何获取一个结构体的成员数量呢？\n结构体成员数量获取\r注意到，c++11开始引入了均匀初始化，即对于Person结构体，支持如下初始化方式：\n1 Person p{{}, {}}; 编译器会对其每个成员单独调用默认构造，对于基础类型，会执行值初始化，赋值为0，如果只是这样也不足以被我们使用，主要他还支持：\n1 Person p{{}}; 即顺序初始化，对于没有显示调用{}的成员仍然会调用默认构造函数，而当{}数量过多时\n1 Person p{{}, {}, {}}; 就会报错，而这就让我们有机可乘了，我们可以递归的对一个结构体尝试初始化，利用SFINAE特性（c++20就可以使用constexpr和require做编译期选择了），即使构造失败也不会导致编译失败，可以作为递归尝试的结束符，而这里栈的深度就是一个结构体的成员个数。\n1 2 3 4 5 6 7 8 9 template \u0026lt;typename T\u0026gt; consteval size_t countMember(auto\u0026amp;\u0026amp;... Args) { if constexpr (std::is_constructible_v\u0026lt;T, Args...\u0026gt;) { return sizeof...(Args) - 1; } else { return countMember\u0026lt;T\u0026gt;(Args..., {}); } } 但是这样写会编译错误，对于countMember的函数参数，传入一个{}并不能让编译器确定传入类型，但我们又确实需要一个任意类型的{}来进行构造，这时候就可以构造一个空的类型，并重载其类型转换函数：\n1 2 3 4 struct AnyType { template \u0026lt;typename T\u0026gt; operator T(); }; 这样就能实现一个确认的类型，并在参与构造时能够自适应类型，再对刚才的递归函数做修改：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 template \u0026lt;typename T\u0026gt; consteval size_t countMember(auto\u0026amp;\u0026amp;... Args) { if constexpr (std::is_constructible_v\u0026lt;T, Args...\u0026gt;) { return sizeof...(Args) - 1; } else { return countMember\u0026lt;T\u0026gt;(Args..., AnyType{}); } } template \u0026lt;typename T\u0026gt; constexpr size_t member_count_v = countMember\u0026lt;T\u0026gt;(); std::cout \u0026lt;\u0026lt; member_count_v\u0026lt;Person\u0026gt; \u0026lt;\u0026lt; std::endl; // out: 2 到此我们就能对之前的结构化绑定，针对不同的结构体成员数量做偏特化了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 template \u0026lt;AggregateType T\u0026gt; using member_array = std::array\u0026lt;std::string_view, members_count_v\u0026lt;remove_cvref_t\u0026lt;T\u0026gt;\u0026gt;\u0026gt;; // get members tuple template \u0026lt;AggregateType T\u0026gt; inline constexpr auto struct_members_to_tuple() { // 在这里针对不同的结构体成员数量做偏特化 return get_member_references_tuple\u0026lt;T, members_count_v\u0026lt;T\u0026gt;\u0026gt;::get_tuple(); } // get members array template \u0026lt;AggregateType T\u0026gt; inline consteval member_array\u0026lt;T\u0026gt; struct_members_to_array() { using U = remove_cvref_t\u0026lt;T\u0026gt;; constexpr auto tuple = struct_members_to_tuple\u0026lt;U\u0026gt;(); return [\u0026amp;] \u0026lt;size_t... Is\u0026gt;(std::index_sequence\u0026lt;Is...\u0026gt;) { // 初始化列表对std::array进行初始化 return member_array\u0026lt;T\u0026gt;{get_member_name\u0026lt;\u0026amp;std::get\u0026lt;Is\u0026gt;(tuple)\u0026gt;()...}; }(std::make_index_sequence\u0026lt;members_count_v\u0026lt;U\u0026gt;\u0026gt;()); } 结构体成员引用获取\r现在，我们就能够获得结构体成员名称的array了，再进一步拓展上面代码，在我们原本的宏定义基础上添加对运行时变量引用的获取（因为引用也要用到结构化绑定，也要用到打表的结构体）：\n1 2 3 4 5 6 7 8 9 10 11 12 #define GET_MEMBER_TUPLE_HELPER(n, ...) \\ template \u0026lt;AggregateType T\u0026gt; \\ struct get_member_references_tuple\u0026lt;T, n\u0026gt; { \\ inline static constexpr auto get_tuple() { \\ auto\u0026amp; [__VA_ARGS__] = Wrapper\u0026lt;T\u0026gt;::value;\t\\ return std::tie(__VA_ARGS__);\t\\ } \\ inline static decltype(auto) get_reference_value(T\u0026amp;\u0026amp; t) { \\ auto\u0026amp;\u0026amp; [__VA_ARGS__] = std::forward\u0026lt;T\u0026gt;(t);\t\\ return std::tie(__VA_ARGS__);\t\\ }\t\\ };\t与获取静态对象的过程相同，只不过将方法的constexpr关键字去掉，改为运行时调用的函数，其实获取名称时也可以去掉constexpr，但这是可以在编译期完成的事情，就不要放在运行时做了。\n获取指定索引的运行时成员引用：\n1 2 3 4 5 6 7 8 // get members reference template \u0026lt;size_t Index, typename T\u0026gt; inline decltype(auto) struct_member_reference(T\u0026amp;\u0026amp; t) { using U = remove_cvref_t\u0026lt;T\u0026gt;; constexpr size_t count = members_count_v\u0026lt;U\u0026gt;; static_assert(Index \u0026lt; count, \u0026#34;Index out of range\u0026#34;); return std::get\u0026lt;Index\u0026gt;(get_member_references_tuple\u0026lt;T, count\u0026gt;::get_reference_value(std::forward\u0026lt;T\u0026gt;(t))); } 这里需要注意，要使用decltype(auto) 而不是 auto是因为前者能完整的保留表达式返回的原始类型，例如：\n1 2 3 4 int x = 42; int\u0026amp; ref = x; auto a = ref; // Value Type decltype(auto) b = ref; // Reference Type 而这里我们需要返回的是结构体成员的引用，所以需要使用前者作返回值类型推导。\n到这里我们就能基础的获得一个结构体的元信息了，这些信息足够我们实现一个基础的序列化功能了。\n本章总结\r本章的代码见：https://github.com/SSmallOrange/TinyReflection/blob/master/tinyrefl/utils/reflection_get_tuple.hpp\n本章相关测试代码：\nhttps://github.com/SSmallOrange/TinyReflection/blob/master/test/test_get_member_string_and_type_string.cpp\nhttps://github.com/SSmallOrange/TinyReflection/blob/master/test/test_get_member_value.cpp\n下一章我们将基于上述功能实现基础的Json序列化能力。\n","date":"2025-08-12T22:20:20+08:00","image":"https://SSmallOrange.github.io/p/reflection2/20221003212826_4e779.thumb.1000_0_hu_3ed8a23b31eb23f7.jpeg","permalink":"https://SSmallOrange.github.io/p/reflection2/","title":"第二章：获取结构体元数据"},{"content":"第一章：反射语法基础\r对于模板了解不多的同学可以先学习下模板基础，这里推荐博客：模板元编程教程 ，讲的很详细。\n以下是我们在实现反射时会用到的部分语法介绍\n为什么选择 C++20\r首先，实现一个反射功能就需要知道一个对象的：成员名称、成员的值，并且要有修改成员值的能力，而c++因为“零运行时开销”的设计初衷，导致反射迟迟没有被纳入标准（c++26已支持），因为反射往往意味着运行时元数据，这会带来额外内存和性能开销，与零开销原则冲突。\n不过我们可以通过一些其他的方式，实现我们自己的简单的反射功能，不过这肯定会不可避免的带来：\n代码体积膨胀（反射类型越多，体积越大）\n运行时内存增加（运行时保留类型元数据）\n不过在软件工程中，复杂度是守恒的，只会转移不会消失，所以一定程度的编码便利带来一定的开销也是可以接受的。\n通过查找资料发现，目前c++20的反射实现主要思路都是：\n通过结构化绑定和编译器内置的宏（MSVC：__FUNCSIG__、clang、gcc：__PRETTY_FUNCTION__）来获得对象的成员名称 通过结构化绑定获得对象的成员引用（可以获得和修改对象数据） 这里的__FUNCSIG__顾名思义是获得函数签名的宏，对于如下调用：\n1 2 3 4 5 6 7 8 9 10 11 template \u0026lt;auto val\u0026gt; inline void get_func_name_template() { std::cout \u0026lt;\u0026lt; __FUNCSIG__ \u0026lt;\u0026lt; std::endl; } struct Person { int m_age; std::string m_name; }; static Person p; get_func_name_template\u0026lt;\u0026amp;p.m_name\u0026gt;(); // MSVC C++20编译输出：void __cdecl get_func_name_template\u0026lt;\u0026amp;p.m_name\u0026gt;(void) 可以看到，输出中包含了我们需要的成员名称，对于这种固定模板，我们可以很容易的获得他的成员名称，但是如上代码在C++17是无法编译通过的，C++17需要如下格式：\n1 get_func_name_template\u0026lt;\u0026amp;p\u0026gt;(); 原因在于：C++17对于非类型模板参数的值类型限制很严格，不允许将对象的子对象地址作为模板入参，这就直接导致了C++20以下的版本通常只能通过如下方式手动注册对象的元信息：\n1 REFLECTION(Person, m_age, m_name); 这就直接导致了想要一行代码实现序列化和反序列化，只能以C++20作为基础来实现。\n而其他的限制通常都可以通过SFINAE来规避，只不过实现起来会更加复杂。\n同时C++20还有很多方便我们实现的特性，如：支持模板的Lambda表达式，concept和requires等，能够大大提高我们的代码可读性，提高开发效率。\n语法介绍\r对模板Lambda表达式的支持\r在 C++20 中，你可以让 Lambda 接收模板参数，这在编译期展开成员信息时非常方便。\n1 2 3 4 5 auto print_indices = []\u0026lt;std::size_t... Is\u0026gt;(std::index_sequence\u0026lt;Is...\u0026gt;) { // C++20支持模板 ((std::cout \u0026lt;\u0026lt; Is \u0026lt;\u0026lt; \u0026#34; \u0026#34;), ...); // C++17 折叠表达式 }; print_indices(std::make_index_sequence\u0026lt;5\u0026gt;{}); // 输出：0 1 2 3 4 这里的折叠表达式能够将模板参数包进行展开，这种写法在后面会经常用到，是反射利器。\nconcept 与 requires\rC++17 的 SFINAE（Substitution Failure Is Not An Error）虽然可以限制模板的使用条件，但写法晦涩难懂，错误信息又长又吓人。C++20 的 concept / requires 让约束直接写在模板签名上，可读性高很多。\n例子（判断类型是否可加）：\n1 2 3 4 5 6 7 8 9 10 11 12 template \u0026lt;typename T\u0026gt; concept Addable = requires(T a, T b) { { a + b } -\u0026gt; std::convertible_to\u0026lt;T\u0026gt;; }; template \u0026lt;Addable T\u0026gt; T add(T a, T b) { return a + b; } int main() { std::cout \u0026lt;\u0026lt; add(3, 4) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // OK // std::cout \u0026lt;\u0026lt; add(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;); // 编译错误，error C2672: “add”: 未找到匹配的重载函数 } 对比 C++17：\n1 2 3 4 template \u0026lt;typename T, typename = std::enable_if_t\u0026lt; std::is_convertible_v\u0026lt;decltype(std::declval\u0026lt;T\u0026gt;() + std::declval\u0026lt;T\u0026gt;()), T\u0026gt; \u0026gt;\u0026gt; T add(T a, T b) { return a + b; } // SFINAE 是不是瞬间清爽了？这就是 concept / requires 的魅力。\nconcept相当于一个编译期的bool值，可以直接使用在模板中做类型约束\nrequires有以下几种写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 1 template \u0026lt;typename T\u0026gt; requires std::integral\u0026lt;T\u0026gt; // 直接写在模板尾部 T multiply_by_two(T x) {} // 2 template \u0026lt;typename T\u0026gt; T multiply_by_two(T x) requires std::integral\u0026lt;T\u0026gt; {} // 写在函数声明后 // 3 requires (参数列表) { 要检测的表达式; ... }; template \u0026lt;typename T\u0026gt; concept Incrementable = requires(T x) { // 对模板参数做多重约束 { ++x } -\u0026gt; std::same_as\u0026lt;T\u0026amp;\u0026gt;; // 支持使用++运算符并且返回类型必须是 T\u0026amp; { --x };\t// 支持--运算符 }; 在c++20中，约束也被算作重载决议的一种，所以对于如下代码：\n1 2 3 4 5 6 7 8 template \u0026lt;OutputStream Stream, typename T\u0026gt; inline void to_json_value(Stream\u0026amp;\u0026amp; s, T\u0026amp;\u0026amp; object) requires is_custom_type_v\u0026lt;T\u0026gt;; template \u0026lt;OutputStream Stream, typename T\u0026gt; inline void to_json_value(Stream\u0026amp;\u0026amp; s, T\u0026amp;\u0026amp; object) requires is_sequence_container_v\u0026lt;T\u0026gt;; template \u0026lt;OutputStream Stream, typename T\u0026gt; inline void to_json_value(Stream\u0026amp;\u0026amp; s, T\u0026amp;\u0026amp; object) requires is_associative_container_v\u0026lt;T\u0026gt;; 通过使用requires能够非常清爽的实现对不同类型的不同处理，可读性很高，如果按照SFINAE写法如下：\n1 2 template \u0026lt;class S, class T, std::enable_if_t\u0026lt;is_custom_type_v\u0026lt;T\u0026gt;, int\u0026gt; = 0\u0026gt; void to_json_value(S\u0026amp;\u0026amp;, T\u0026amp;\u0026amp;); 其中对于类型S和T想要进一步约束还会更复杂。\n结构化绑定（Structured Bindings）和tuple\r结构化绑定是 C++17 引入的语法，让你可以用类似解构赋值的方式，直接把一个struct或 tuple 拆成多个变量。\n1 2 3 4 5 std::tuple\u0026lt;int, double, char\u0026gt; t{42, 3.14, \u0026#39;x\u0026#39;}; // tuple auto [i, d, c] = t; struct Person {int m_age; std::string m_name; }; // struct auto [a, n] = p;\t// 按值绑定 auto\u0026amp; [ra, rn] = p; // 按引用绑定 在编译期反射中，结构化绑定是获取成员引用 tuple的核心手段之一。\nstd::tuple 是 C++ 标准库里的一种固定长度、多类型的集合容器，从定义看就非常适合作为结构体元信息的存储单位。\ntuple构造方式如下：\n1 std::tuple\u0026lt;int, double, std::string\u0026gt; t1(42, 3.14, \u0026#34;hello\u0026#34;); 也可以通过std::make_tuple进行构造：\n1 auto t = std::make_tuple(42, 3.14, std::string(\u0026#34;hello\u0026#34;)); // 类型自动推导：std::tuple\u0026lt;int, double, std::string\u0026gt; 通过make_tuple构造tuple会通过值拷贝的方式进行构造\n还可以通过std::tie进行构造：\n1 auto t = std::tie(person.m_age, person.m_name); 这里构造出的tuple会持有原对象的引用，可以通过std::get拿到引用并对值做修改\n可变参数模板与参数包展开（Variadic Templates \u0026amp; Pack Expansion）\r这是 C++11 引入的重要语法，用来处理任意数量的模板参数\n可变参数模板\r1 2 3 4 5 6 7 8 template \u0026lt;typename... Args\u0026gt; void print_all(Args... args) { (std::cout \u0026lt;\u0026lt; ... \u0026lt;\u0026lt; args) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // C++17 折叠表达式 } int main() { print_all(1, 2.5, \u0026#34;hello\u0026#34;); // 输出：12.5hello } 参数包展开\r参数包展开就是用 ... 把一段模式按参数包逐项替换，然后拼成一串。\n1 2 3 4 template \u0026lt;typename... Ts\u0026gt; using MyTuple = std::tuple\u0026lt;Ts...\u0026gt;; using T = MyTuple\u0026lt;int, double, std::string\u0026gt;; // 等价于 tuple\u0026lt;int, double, string\u0026gt; 例子（反射中常见模式展开）：\n1 2 3 4 5 6 7 template \u0026lt;std::size_t... Is\u0026gt; constexpr std::array\u0026lt;int, sizeof...(Is)\u0026gt; get_array(std::index_sequence\u0026lt;Is...\u0026gt;) { return std::array\u0026lt;int, sizeof...(Is)\u0026gt;{ { static_cast\u0026lt;int\u0026gt;(Is)... } }; } get_array(std::make_index_sequence\u0026lt;5\u0026gt;{}); // 构造array: [1, 2, 3, 4, 5] 这里的 ... 就是参数包展开，它会依次替换 Is，展开为：{1, 2, 3, 4, 5}。\n本章总结\rC++20 的三大升级（模板 Lambda、concept/requires、NTTP 放宽）是非侵入式反射的关键。 结构化绑定让我们在编译期轻松获取成员引用。 concept 与 requires让模板约束变得优雅可读。 可变参数模板与参数包展开让我们能在编译期遍历所有成员类型，并生成序列化/反序列化代码。 下一章，我们会在这些语法基础上，开始构建编译期静态反射的核心机制，看看如何一步步获取结构体的成员数量、成员引用 tuple、成员名称。\n","date":"2025-08-11T20:00:31+08:00","image":"https://SSmallOrange.github.io/p/reflection/M6Se7Y0qHBanWml.thumb.1000_0_hu_1452b3224ca81446.jpg","permalink":"https://SSmallOrange.github.io/p/reflection/","title":"第一章：反射语法基础"}]